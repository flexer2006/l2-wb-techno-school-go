package three

// package main

// func Foo() error {
//   var err *os.PathError = nil
//   return err
// }

// func main() {
//   err := Foo()
//   fmt.Println(err)
//   fmt.Println(err == nil)
// }

// Программа выведет:
// <nil>
// false

// Потому что функция Foo возвращает указатель на os.PathError, который равен nil.
// Но в Go интерфейсы устроены так: каждый интерфейс внутри имеет два поля -
// тип данных и указатель на сами данные.
// Когда мы присваиваем nil указатель интерфейсу error, интерфейс не становится nil,
// потому что тип (*os.PathError) все равно записан.
// Поэтому сравнение err == nil дает false.

// Интерфейсы в Go - это как контракты: они говорят, какие методы должен иметь тип.
// Например, error требует метод Error().
// Внутри интерфейс хранит информацию о типе и его данных.

// Пустой интерфейс interface{} - это интерфейс без методов.
// Он может хранить любойы тип, потому что не требует никаких методов.
