package six

/*
package main

import (
	"fmt"
)

func main() {
	var s = []string{"1", "2", "3"}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(i []string) {
	i[0] = "3"
	i = append(i, "4")
	i[1] = "5"
	i = append(i, "6")
}
*/

// Вывод: [3 2 3]
// В Go срезы передаются в функции по значению, но это значение — структура с указателем на базовый массив, длиной и ёмкостью.
// Изменения элементов среза в пределах текущей длины видны снаружи, так как указатель на массив общий (например, i[0] = "3" изменяет s[0] на "3").
// Операция append может увеличить длину среза. Если ёмкость позволяет, элементы добавляются в тот же массив. Если нет (например, при переполнении ёмкости), создаётся новый массив, и срез i начинает указывать на него.
// В этом коде append(i, "4") создаёт новый массив (предполагая, что исходная ёмкость s равна 3), так что последующие изменения i[1] = "5" и append(i, "6") затрагивают только новый массив. Оригинальный срез s остаётся с исходным массивом: ["3", "2", "3"].
